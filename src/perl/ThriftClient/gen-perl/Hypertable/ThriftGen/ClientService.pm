#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Hypertable::ThriftGen::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hypertable::ThriftGen::ClientService_namespace_create_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_create_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_create_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_create_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_create_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_alter_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_alter_table_args->mk_accessors( qw( ns table_name schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_alter_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{schema});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_alter_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRING, 3);
    $xfer += $output->writeString($self->{schema});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_alter_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_alter_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_alter_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_alter_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_args->mk_accessors( qw( queue_size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queue_size} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queue_size}) {
      $self->{queue_size} = $vals->{queue_size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{queue_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_args');
  if (defined $self->{queue_size}) {
    $xfer += $output->writeFieldBegin('queue_size', TType::I32, 1);
    $xfer += $output->writeI32($self->{queue_size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_args->mk_accessors( qw( queue_size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queue_size} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queue_size}) {
      $self->{queue_size} = $vals->{queue_size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{queue_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_args');
  if (defined $self->{queue_size}) {
    $xfer += $output->writeFieldBegin('queue_size', TType::I32, 1);
    $xfer += $output->writeI32($self->{queue_size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_future_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_future_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Result();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Result();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultAsArrays();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultAsArrays();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_get_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_get_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_get_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultSerialized();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_get_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_future_result_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_future_result_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_future_result_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::ResultSerialized();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_future_result_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_empty_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_empty_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_empty_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_empty_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_full_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_full_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_full_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_full_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_is_cancelled_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_is_cancelled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_is_cancelled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_is_cancelled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_has_outstanding_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_has_outstanding_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_has_outstanding_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_has_outstanding_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_future_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_future_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_future_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_future_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_args->mk_accessors( qw( ff ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ff} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ff}) {
      $self->{ff} = $vals->{ff};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ff});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_args');
  if (defined $self->{ff}) {
    $xfer += $output->writeFieldBegin('ff', TType::I64, 1);
    $xfer += $output->writeI64($self->{ff});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_future_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_future_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_future_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_future_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_args->mk_accessors( qw( ns table_name future scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 4);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_scanner_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_scanner_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_scanner_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_scanner_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_scanner_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_scanner_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_scanner_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_scanner_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_scanner_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_scanner_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size67 = 0;
          $self->{success} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem72->read($input);
            push(@{$self->{success}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter73 (@{$self->{success}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{success} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem79->read($input);
            push(@{$self->{success}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter80 (@{$self->{success}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{success} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            {
              my $_size87 = 0;
              $elem86 = [];
              my $_etype90 = 0;
              $xfer += $input->readListBegin(\$_etype90, \$_size87);
              for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
              {
                my $elem92 = undef;
                $xfer += $input->readString(\$elem92);
                push(@{$elem86},$elem92);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter93 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter93}}));
            {
              foreach my $iter94 (@{${iter93}}) 
              {
                $xfer += $output->writeString($iter94);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size95 = 0;
          $self->{success} = [];
          my $_etype98 = 0;
          $xfer += $input->readListBegin(\$_etype98, \$_size95);
          for (my $_i99 = 0; $_i99 < $_size95; ++$_i99)
          {
            my $elem100 = undef;
            {
              my $_size101 = 0;
              $elem100 = [];
              my $_etype104 = 0;
              $xfer += $input->readListBegin(\$_etype104, \$_size101);
              for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
              {
                my $elem106 = undef;
                $xfer += $input->readString(\$elem106);
                push(@{$elem100},$elem106);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem100);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter107 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter107}}));
            {
              foreach my $iter108 (@{${iter107}}) 
              {
                $xfer += $output->writeString($iter108);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size109 = 0;
          $self->{success} = [];
          my $_etype112 = 0;
          $xfer += $input->readListBegin(\$_etype112, \$_size109);
          for (my $_i113 = 0; $_i113 < $_size109; ++$_i113)
          {
            my $elem114 = undef;
            $elem114 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem114->read($input);
            push(@{$self->{success}},$elem114);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter115 (@{$self->{success}}) 
        {
          $xfer += ${iter115}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size116 = 0;
          $self->{success} = [];
          my $_etype119 = 0;
          $xfer += $input->readListBegin(\$_etype119, \$_size116);
          for (my $_i120 = 0; $_i120 < $_size116; ++$_i120)
          {
            my $elem121 = undef;
            $elem121 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem121->read($input);
            push(@{$self->{success}},$elem121);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter122 (@{$self->{success}}) 
        {
          $xfer += ${iter122}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size123 = 0;
          $self->{success} = [];
          my $_etype126 = 0;
          $xfer += $input->readListBegin(\$_etype126, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $elem128 = undef;
            {
              my $_size129 = 0;
              $elem128 = [];
              my $_etype132 = 0;
              $xfer += $input->readListBegin(\$_etype132, \$_size129);
              for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
              {
                my $elem134 = undef;
                $xfer += $input->readString(\$elem134);
                push(@{$elem128},$elem134);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem128);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter135 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter135}}));
            {
              foreach my $iter136 (@{${iter135}}) 
              {
                $xfer += $output->writeString($iter136);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size137 = 0;
          $self->{success} = [];
          my $_etype140 = 0;
          $xfer += $input->readListBegin(\$_etype140, \$_size137);
          for (my $_i141 = 0; $_i141 < $_size137; ++$_i141)
          {
            my $elem142 = undef;
            {
              my $_size143 = 0;
              $elem142 = [];
              my $_etype146 = 0;
              $xfer += $input->readListBegin(\$_etype146, \$_size143);
              for (my $_i147 = 0; $_i147 < $_size143; ++$_i147)
              {
                my $elem148 = undef;
                $xfer += $input->readString(\$elem148);
                push(@{$elem142},$elem148);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem142);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter149 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter149}}));
            {
              foreach my $iter150 (@{${iter149}}) 
              {
                $xfer += $output->writeString($iter150);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_scanner_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_scanner_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_args->mk_accessors( qw( scanner ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scanner} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scanner}) {
      $self->{scanner} = $vals->{scanner};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{scanner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_args');
  if (defined $self->{scanner}) {
    $xfer += $output->writeFieldBegin('scanner', TType::I64, 1);
    $xfer += $output->writeI64($self->{scanner});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_next_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_next_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_next_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_next_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size151 = 0;
          $self->{success} = [];
          my $_etype154 = 0;
          $xfer += $input->readListBegin(\$_etype154, \$_size151);
          for (my $_i155 = 0; $_i155 < $_size151; ++$_i155)
          {
            my $elem156 = undef;
            $elem156 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem156->read($input);
            push(@{$self->{success}},$elem156);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter157 (@{$self->{success}}) 
        {
          $xfer += ${iter157}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_args->mk_accessors( qw( ns name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size158 = 0;
          $self->{success} = [];
          my $_etype161 = 0;
          $xfer += $input->readListBegin(\$_etype161, \$_size158);
          for (my $_i162 = 0; $_i162 < $_size158; ++$_i162)
          {
            my $elem163 = undef;
            {
              my $_size164 = 0;
              $elem163 = [];
              my $_etype167 = 0;
              $xfer += $input->readListBegin(\$_etype167, \$_size164);
              for (my $_i168 = 0; $_i168 < $_size164; ++$_i168)
              {
                my $elem169 = undef;
                $xfer += $input->readString(\$elem169);
                push(@{$elem163},$elem169);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem163);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter170 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter170}}));
            {
              foreach my $iter171 (@{${iter170}}) 
              {
                $xfer += $output->writeString($iter171);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_args->mk_accessors( qw( ns table_name row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_row_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_row_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_row_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_row_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_args->mk_accessors( qw( ns table_name row column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 3);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 4);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cell_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cell_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_args->mk_accessors( qw( ns table_name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size172 = 0;
          $self->{success} = [];
          my $_etype175 = 0;
          $xfer += $input->readListBegin(\$_etype175, \$_size172);
          for (my $_i176 = 0; $_i176 < $_size172; ++$_i176)
          {
            my $elem177 = undef;
            $elem177 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem177->read($input);
            push(@{$self->{success}},$elem177);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter178 (@{$self->{success}}) 
        {
          $xfer += ${iter178}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size179 = 0;
          $self->{success} = [];
          my $_etype182 = 0;
          $xfer += $input->readListBegin(\$_etype182, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $elem184 = undef;
            {
              my $_size185 = 0;
              $elem184 = [];
              my $_etype188 = 0;
              $xfer += $input->readListBegin(\$_etype188, \$_size185);
              for (my $_i189 = 0; $_i189 < $_size185; ++$_i189)
              {
                my $elem190 = undef;
                $xfer += $input->readString(\$elem190);
                push(@{$elem184},$elem190);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem184);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_as_arrays_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter191 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter191}}));
            {
              foreach my $iter192 (@{${iter191}}) 
              {
                $xfer += $output->writeString($iter192);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_args->mk_accessors( qw( ns name scan_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{scan_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{scan_spec}) {
      $self->{scan_spec} = $vals->{scan_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan_spec} = new Hypertable::ThriftGen::ScanSpec();
        $xfer += $self->{scan_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan_spec}) {
    $xfer += $output->writeFieldBegin('scan_spec', TType::STRUCT, 3);
    $xfer += $self->{scan_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_cells_serialized_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_cells_serialized_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args->mk_accessors( qw( ns table_name mutate_spec ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_refresh_shared_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_refresh_shared_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size193 = 0;
          $self->{cells} = [];
          my $_etype196 = 0;
          $xfer += $input->readListBegin(\$_etype196, \$_size193);
          for (my $_i197 = 0; $_i197 < $_size193; ++$_i197)
          {
            my $elem198 = undef;
            $elem198 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem198->read($input);
            push(@{$self->{cells}},$elem198);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter199 (@{$self->{cells}}) 
        {
          $xfer += ${iter199}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args->mk_accessors( qw( ns table_name mutate_spec cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size200 = 0;
          $self->{cells} = [];
          my $_etype203 = 0;
          $xfer += $input->readListBegin(\$_etype203, \$_size200);
          for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
          {
            my $elem205 = undef;
            {
              my $_size206 = 0;
              $elem205 = [];
              my $_etype209 = 0;
              $xfer += $input->readListBegin(\$_etype209, \$_size206);
              for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
              {
                my $elem211 = undef;
                $xfer += $input->readString(\$elem211);
                push(@{$elem205},$elem211);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem205);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter212 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter212}}));
            {
              foreach my $iter213 (@{${iter212}}) 
              {
                $xfer += $output->writeString($iter213);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 4);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_args->mk_accessors( qw( ns table_name mutate_spec cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{mutate_spec} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{mutate_spec}) {
      $self->{mutate_spec} = $vals->{mutate_spec};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutate_spec} = new Hypertable::ThriftGen::MutateSpec();
        $xfer += $self->{mutate_spec}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size214 = 0;
          $self->{cell} = [];
          my $_etype217 = 0;
          $xfer += $input->readListBegin(\$_etype217, \$_size214);
          for (my $_i218 = 0; $_i218 < $_size214; ++$_i218)
          {
            my $elem219 = undef;
            $xfer += $input->readString(\$elem219);
            push(@{$self->{cell}},$elem219);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutate_spec}) {
    $xfer += $output->writeFieldBegin('mutate_spec', TType::STRUCT, 3);
    $xfer += $self->{mutate_spec}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter220 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter220);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_offer_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_offer_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_offer_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_offer_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_args->mk_accessors( qw( ns table_name flags flush_interval ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{flags} = 0;
  $self->{flush_interval} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{flush_interval}) {
      $self->{flush_interval} = $vals->{flush_interval};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flush_interval});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 3);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush_interval}) {
    $xfer += $output->writeFieldBegin('flush_interval', TType::I32, 4);
    $xfer += $output->writeI32($self->{flush_interval});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_open_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_open_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_open_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_args->mk_accessors( qw( ns table_name future flags ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{future} = undef;
  $self->{flags} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{future}) {
      $self->{future} = $vals->{future};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{future});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{future}) {
    $xfer += $output->writeFieldBegin('future', TType::I64, 3);
    $xfer += $output->writeI64($self->{future});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::I32, 4);
    $xfer += $output->writeI32($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_open_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_open_mutator_async_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_open_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_open_mutator_async_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_cancel_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_cancel_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_cancel_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_cancel_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_cancel_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_cancel_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_cancel_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_cancel_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_close_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_close_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_close_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_close_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_close_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_close_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_close_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_close_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 3);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size221 = 0;
          $self->{cell} = [];
          my $_etype224 = 0;
          $xfer += $input->readListBegin(\$_etype224, \$_size221);
          for (my $_i225 = 0; $_i225 < $_size221; ++$_i225)
          {
            my $elem226 = undef;
            $xfer += $input->readString(\$elem226);
            push(@{$self->{cell}},$elem226);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter227 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter227);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_args->mk_accessors( qw( ns table_name cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size228 = 0;
          $self->{cell} = [];
          my $_etype231 = 0;
          $xfer += $input->readListBegin(\$_etype231, \$_size228);
          for (my $_i232 = 0; $_i232 < $_size228; ++$_i232)
          {
            my $elem233 = undef;
            $xfer += $input->readString(\$elem233);
            push(@{$self->{cell}},$elem233);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter234 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter234);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size235 = 0;
          $self->{cells} = [];
          my $_etype238 = 0;
          $xfer += $input->readListBegin(\$_etype238, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $elem240 = undef;
            $elem240 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem240->read($input);
            push(@{$self->{cells}},$elem240);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter241 (@{$self->{cells}}) 
        {
          $xfer += ${iter241}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size242 = 0;
          $self->{cells} = [];
          my $_etype245 = 0;
          $xfer += $input->readListBegin(\$_etype245, \$_size242);
          for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
          {
            my $elem247 = undef;
            $elem247 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem247->read($input);
            push(@{$self->{cells}},$elem247);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter248 (@{$self->{cells}}) 
        {
          $xfer += ${iter248}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size249 = 0;
          $self->{cells} = [];
          my $_etype252 = 0;
          $xfer += $input->readListBegin(\$_etype252, \$_size249);
          for (my $_i253 = 0; $_i253 < $_size249; ++$_i253)
          {
            my $elem254 = undef;
            {
              my $_size255 = 0;
              $elem254 = [];
              my $_etype258 = 0;
              $xfer += $input->readListBegin(\$_etype258, \$_size255);
              for (my $_i259 = 0; $_i259 < $_size255; ++$_i259)
              {
                my $elem260 = undef;
                $xfer += $input->readString(\$elem260);
                push(@{$elem254},$elem260);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem254);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter261 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter261}}));
            {
              foreach my $iter262 (@{${iter261}}) 
              {
                $xfer += $output->writeString($iter262);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args->mk_accessors( qw( ns table_name cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size263 = 0;
          $self->{cells} = [];
          my $_etype266 = 0;
          $xfer += $input->readListBegin(\$_etype266, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $elem268 = undef;
            {
              my $_size269 = 0;
              $elem268 = [];
              my $_etype272 = 0;
              $xfer += $input->readListBegin(\$_etype272, \$_size269);
              for (my $_i273 = 0; $_i273 < $_size269; ++$_i273)
              {
                my $elem274 = undef;
                $xfer += $input->readString(\$elem274);
                push(@{$elem268},$elem274);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem268);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter275 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter275}}));
            {
              foreach my $iter276 (@{${iter275}}) 
              {
                $xfer += $output->writeString($iter276);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_args->mk_accessors( qw( ns table_name cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 3);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cell} = new Hypertable::ThriftGen::Cell();
        $xfer += $self->{cell}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
    $xfer += $self->{cell}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size277 = 0;
          $self->{cell} = [];
          my $_etype280 = 0;
          $xfer += $input->readListBegin(\$_etype280, \$_size277);
          for (my $_i281 = 0; $_i281 < $_size277; ++$_i281)
          {
            my $elem282 = undef;
            $xfer += $input->readString(\$elem282);
            push(@{$self->{cell}},$elem282);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter283 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter283);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cell_as_array_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cell_as_array_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args->mk_accessors( qw( mutator cell ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cell} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cell}) {
      $self->{cell} = $vals->{cell};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size284 = 0;
          $self->{cell} = [];
          my $_etype287 = 0;
          $xfer += $input->readListBegin(\$_etype287, \$_size284);
          for (my $_i288 = 0; $_i288 < $_size284; ++$_i288)
          {
            my $elem289 = undef;
            $xfer += $input->readString(\$elem289);
            push(@{$self->{cell}},$elem289);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cell}) {
    $xfer += $output->writeFieldBegin('cell', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{cell}}));
      {
        foreach my $iter290 (@{$self->{cell}}) 
        {
          $xfer += $output->writeString($iter290);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cell_as_array_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cell_as_array_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size291 = 0;
          $self->{cells} = [];
          my $_etype294 = 0;
          $xfer += $input->readListBegin(\$_etype294, \$_size291);
          for (my $_i295 = 0; $_i295 < $_size291; ++$_i295)
          {
            my $elem296 = undef;
            $elem296 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem296->read($input);
            push(@{$self->{cells}},$elem296);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter297 (@{$self->{cells}}) 
        {
          $xfer += ${iter297}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size298 = 0;
          $self->{cells} = [];
          my $_etype301 = 0;
          $xfer += $input->readListBegin(\$_etype301, \$_size298);
          for (my $_i302 = 0; $_i302 < $_size298; ++$_i302)
          {
            my $elem303 = undef;
            $elem303 = new Hypertable::ThriftGen::Cell();
            $xfer += $elem303->read($input);
            push(@{$self->{cells}},$elem303);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cells}}));
      {
        foreach my $iter304 (@{$self->{cells}}) 
        {
          $xfer += ${iter304}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size305 = 0;
          $self->{cells} = [];
          my $_etype308 = 0;
          $xfer += $input->readListBegin(\$_etype308, \$_size305);
          for (my $_i309 = 0; $_i309 < $_size305; ++$_i309)
          {
            my $elem310 = undef;
            {
              my $_size311 = 0;
              $elem310 = [];
              my $_etype314 = 0;
              $xfer += $input->readListBegin(\$_etype314, \$_size311);
              for (my $_i315 = 0; $_i315 < $_size311; ++$_i315)
              {
                my $elem316 = undef;
                $xfer += $input->readString(\$elem316);
                push(@{$elem310},$elem316);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem310);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter317 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter317}}));
            {
              foreach my $iter318 (@{${iter317}}) 
              {
                $xfer += $output->writeString($iter318);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_as_arrays_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_as_arrays_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args->mk_accessors( qw( mutator cells ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size319 = 0;
          $self->{cells} = [];
          my $_etype322 = 0;
          $xfer += $input->readListBegin(\$_etype322, \$_size319);
          for (my $_i323 = 0; $_i323 < $_size319; ++$_i323)
          {
            my $elem324 = undef;
            {
              my $_size325 = 0;
              $elem324 = [];
              my $_etype328 = 0;
              $xfer += $input->readListBegin(\$_etype328, \$_size325);
              for (my $_i329 = 0; $_i329 < $_size325; ++$_i329)
              {
                my $elem330 = undef;
                $xfer += $input->readString(\$elem330);
                push(@{$elem324},$elem330);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{cells}},$elem324);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{cells}}));
      {
        foreach my $iter331 (@{$self->{cells}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter331}}));
            {
              foreach my $iter332 (@{${iter331}}) 
              {
                $xfer += $output->writeString($iter332);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_as_arrays_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_as_arrays_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_set_cells_serialized_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_set_cells_serialized_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args->mk_accessors( qw( mutator cells flush ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  $self->{cells} = undef;
  $self->{flush} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
    if (defined $vals->{cells}) {
      $self->{cells} = $vals->{cells};
    }
    if (defined $vals->{flush}) {
      $self->{flush} = $vals->{flush};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cells});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{flush});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cells}) {
    $xfer += $output->writeFieldBegin('cells', TType::STRING, 2);
    $xfer += $output->writeString($self->{cells});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flush}) {
    $xfer += $output->writeFieldBegin('flush', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{flush});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_set_cells_serialized_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_set_cells_serialized_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_async_mutator_flush_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_async_mutator_flush_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_async_mutator_flush_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_async_mutator_flush_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_args->mk_accessors( qw( mutator ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutator} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutator}) {
      $self->{mutator} = $vals->{mutator};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{mutator});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_args');
  if (defined $self->{mutator}) {
    $xfer += $output->writeFieldBegin('mutator', TType::I64, 1);
    $xfer += $output->writeI64($self->{mutator});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_flush_mutator_async_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_flush_mutator_async_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_flush_mutator_async_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_flush_mutator_async_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_exists_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_namespace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_namespace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_args->mk_accessors( qw( ns name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_exists_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_exists_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_exists_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_exists_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_id_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_id_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_id_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_id_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_str_with_ids_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_str_with_ids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_schema_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hypertable::ThriftGen::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_tables_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size333 = 0;
          $self->{success} = [];
          my $_etype336 = 0;
          $xfer += $input->readListBegin(\$_etype336, \$_size333);
          for (my $_i337 = 0; $_i337 < $_size333; ++$_i337)
          {
            my $elem338 = undef;
            $xfer += $input->readString(\$elem338);
            push(@{$self->{success}},$elem338);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter339 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter339);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_args->mk_accessors( qw( ns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_listing_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_listing_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_listing_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size340 = 0;
          $self->{success} = [];
          my $_etype343 = 0;
          $xfer += $input->readListBegin(\$_etype343, \$_size340);
          for (my $_i344 = 0; $_i344 < $_size340; ++$_i344)
          {
            my $elem345 = undef;
            $elem345 = new Hypertable::ThriftGen::NamespaceListing();
            $xfer += $elem345->read($input);
            push(@{$self->{success}},$elem345);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_listing_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter346 (@{$self->{success}}) 
        {
          $xfer += ${iter346}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_args->mk_accessors( qw( ns table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_get_table_splits_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_get_table_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_get_table_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size347 = 0;
          $self->{success} = [];
          my $_etype350 = 0;
          $xfer += $input->readListBegin(\$_etype350, \$_size347);
          for (my $_i351 = 0; $_i351 < $_size347; ++$_i351)
          {
            my $elem352 = undef;
            $elem352 = new Hypertable::ThriftGen::TableSplit();
            $xfer += $elem352->read($input);
            push(@{$self->{success}},$elem352);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_get_table_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter353 (@{$self->{success}}) 
        {
          $xfer += ${iter353}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_namespace_drop_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_namespace_drop_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_namespace_drop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_namespace_drop_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_args->mk_accessors( qw( ns if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::STRING, 1);
    $xfer += $output->writeString($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_namespace_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_namespace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_namespace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_namespace_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_args->mk_accessors( qw( ns name new_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{new_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{new_name}) {
      $self->{new_name} = $vals->{new_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{new_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_name}) {
    $xfer += $output->writeFieldBegin('new_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{new_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_rename_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_rename_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_rename_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_rename_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_args->mk_accessors( qw( ns name if_exists ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{name} = undef;
  $self->{if_exists} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{if_exists}) {
      $self->{if_exists} = $vals->{if_exists};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{if_exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{if_exists}) {
    $xfer += $output->writeFieldBegin('if_exists', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{if_exists});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_drop_table_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_drop_table_result');
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_generate_guid_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_generate_guid_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_generate_guid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_generate_guid_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_args;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_args->mk_accessors( qw( ns table_name key value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ns} = undef;
  $self->{table_name} = undef;
  $self->{key} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ns}) {
      $self->{ns} = $vals->{ns};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{ns});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{key} = new Hypertable::ThriftGen::Key();
        $xfer += $self->{key}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_args');
  if (defined $self->{ns}) {
    $xfer += $output->writeFieldBegin('ns', TType::I64, 1);
    $xfer += $output->writeI64($self->{ns});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRUCT, 3);
    $xfer += $self->{key}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientService_create_cell_unique_result;
use base qw(Class::Accessor);
Hypertable::ThriftGen::ClientService_create_cell_unique_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{e} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{e}) {
      $self->{e} = $vals->{e};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ClientService_create_cell_unique_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{e} = new Hypertable::ThriftGen::ClientException();
        $xfer += $self->{e}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ClientService_create_cell_unique_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{e}) {
    $xfer += $output->writeFieldBegin('e', TType::STRUCT, 1);
    $xfer += $self->{e}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hypertable::ThriftGen::ClientServiceIf;

use strict;


sub namespace_create{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub create_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  die 'implement interface';
}

sub namespace_open{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub open_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub namespace_close{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub close_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub future_open{
  my $self = shift;
  my $queue_size = shift;

  die 'implement interface';
}

sub open_future{
  my $self = shift;
  my $queue_size = shift;

  die 'implement interface';
}

sub future_cancel{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub cancel_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_get_result{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub get_future_result{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_empty{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_full{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub future_close{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub close_future{
  my $self = shift;
  my $ff = shift;

  die 'implement interface';
}

sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  die 'implement interface';
}

sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  die 'implement interface';
}

sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  die 'implement interface';
}

sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  die 'implement interface';
}

sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  die 'implement interface';
}

sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  die 'implement interface';
}

sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  die 'implement interface';
}

sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  die 'implement interface';
}

sub mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  die 'implement interface';
}

sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  die 'implement interface';
}

sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  die 'implement interface';
}

sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  die 'implement interface';
}

sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  die 'implement interface';
}

sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  die 'implement interface';
}

sub namespace_exists{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_namespace{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub get_listing{
  my $self = shift;
  my $ns = shift;

  die 'implement interface';
}

sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  die 'implement interface';
}

sub generate_guid{
  my $self = shift;

  die 'implement interface';
}

sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  die 'implement interface';
}

package Hypertable::ThriftGen::ClientServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub namespace_create{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_create($ns);
}

sub create_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->create_namespace($ns);
}

sub create_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->create_table($ns, $table_name, $schema);
}

sub alter_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $schema = ($request->{'schema'}) ? $request->{'schema'} : undef;
  return $self->{impl}->alter_table($ns, $table_name, $schema);
}

sub namespace_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_open($ns);
}

sub open_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->open_namespace($ns);
}

sub namespace_close{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_close($ns);
}

sub close_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->close_namespace($ns);
}

sub future_open{
  my ($self, $request) = @_;

  my $queue_size = ($request->{'queue_size'}) ? $request->{'queue_size'} : undef;
  return $self->{impl}->future_open($queue_size);
}

sub open_future{
  my ($self, $request) = @_;

  my $queue_size = ($request->{'queue_size'}) ? $request->{'queue_size'} : undef;
  return $self->{impl}->open_future($queue_size);
}

sub future_cancel{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_cancel($ff);
}

sub cancel_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->cancel_future($ff);
}

sub future_get_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_get_result($ff);
}

sub get_future_result{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->get_future_result($ff);
}

sub future_get_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_get_result_as_arrays($ff);
}

sub get_future_result_as_arrays{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->get_future_result_as_arrays($ff);
}

sub future_get_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_get_result_serialized($ff);
}

sub get_future_result_serialized{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->get_future_result_serialized($ff);
}

sub future_is_empty{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_empty($ff);
}

sub future_is_full{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_full($ff);
}

sub future_is_cancelled{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_is_cancelled($ff);
}

sub future_has_outstanding{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_has_outstanding($ff);
}

sub future_close{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->future_close($ff);
}

sub close_future{
  my ($self, $request) = @_;

  my $ff = ($request->{'ff'}) ? $request->{'ff'} : undef;
  return $self->{impl}->close_future($ff);
}

sub scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->scanner_open($ns, $table_name, $scan_spec);
}

sub open_scanner{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner($ns, $table_name, $scan_spec);
}

sub async_scanner_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->async_scanner_open($ns, $table_name, $future, $scan_spec);
}

sub open_scanner_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->open_scanner_async($ns, $table_name, $future, $scan_spec);
}

sub scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_close($scanner);
}

sub close_scanner{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner($scanner);
}

sub async_scanner_cancel{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_cancel($scanner);
}

sub cancel_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->cancel_scanner_async($scanner);
}

sub async_scanner_close{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->async_scanner_close($scanner);
}

sub close_scanner_async{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->close_scanner_async($scanner);
}

sub scanner_get_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells($scanner);
}

sub next_cells{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells($scanner);
}

sub scanner_get_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_as_arrays($scanner);
}

sub next_cells_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_as_arrays($scanner);
}

sub scanner_get_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_cells_serialized($scanner);
}

sub next_cells_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_cells_serialized($scanner);
}

sub scanner_get_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row($scanner);
}

sub next_row{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row($scanner);
}

sub scanner_get_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_as_arrays($scanner);
}

sub next_row_as_arrays{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_as_arrays($scanner);
}

sub scanner_get_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->scanner_get_row_serialized($scanner);
}

sub next_row_serialized{
  my ($self, $request) = @_;

  my $scanner = ($request->{'scanner'}) ? $request->{'scanner'} : undef;
  return $self->{impl}->next_row_serialized($scanner);
}

sub get_row{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row($ns, $table_name, $row);
}

sub get_row_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_as_arrays($ns, $name, $row);
}

sub get_row_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->get_row_serialized($ns, $table_name, $row);
}

sub get_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  return $self->{impl}->get_cell($ns, $table_name, $row, $column);
}

sub get_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells($ns, $table_name, $scan_spec);
}

sub get_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_as_arrays($ns, $name, $scan_spec);
}

sub get_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $scan_spec = ($request->{'scan_spec'}) ? $request->{'scan_spec'} : undef;
  return $self->{impl}->get_cells_serialized($ns, $name, $scan_spec);
}

sub refresh_shared_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  return $self->{impl}->refresh_shared_mutator($ns, $table_name, $mutate_spec);
}

sub offer_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
}

sub offer_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell($ns, $table_name, $mutate_spec, $cell);
}

sub offer_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $mutate_spec = ($request->{'mutate_spec'}) ? $request->{'mutate_spec'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
}

sub mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->mutator_open($ns, $table_name, $flags, $flush_interval);
}

sub open_mutator{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $flush_interval = ($request->{'flush_interval'}) ? $request->{'flush_interval'} : undef;
  return $self->{impl}->open_mutator($ns, $table_name, $flags, $flush_interval);
}

sub async_mutator_open{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->async_mutator_open($ns, $table_name, $future, $flags);
}

sub open_mutator_async{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $future = ($request->{'future'}) ? $request->{'future'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  return $self->{impl}->open_mutator_async($ns, $table_name, $future, $flags);
}

sub mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_close($mutator);
}

sub close_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator($mutator);
}

sub async_mutator_cancel{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_cancel($mutator);
}

sub cancel_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->cancel_mutator_async($mutator);
}

sub async_mutator_close{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_close($mutator);
}

sub close_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->close_mutator_async($mutator);
}

sub mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell($mutator, $cell);
}

sub set_cell{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell($ns, $table_name, $cell);
}

sub mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array($ns, $table_name, $cell);
}

sub mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells($mutator, $cells);
}

sub set_cells{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells($ns, $table_name, $cells);
}

sub mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays($ns, $table_name, $cells);
}

sub mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->set_cells_serialized($ns, $table_name, $cells, $flush);
}

sub mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->mutator_flush($mutator);
}

sub flush_mutator{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator($mutator);
}

sub async_mutator_set_cell{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell($mutator, $cell);
}

sub set_cell_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_async($mutator, $cell);
}

sub async_mutator_set_cell_as_array{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->async_mutator_set_cell_as_array($mutator, $cell);
}

sub set_cell_as_array_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cell = ($request->{'cell'}) ? $request->{'cell'} : undef;
  return $self->{impl}->set_cell_as_array_async($mutator, $cell);
}

sub async_mutator_set_cells{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells($mutator, $cells);
}

sub set_cells_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_async($mutator, $cells);
}

sub async_mutator_set_cells_as_arrays{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->async_mutator_set_cells_as_arrays($mutator, $cells);
}

sub set_cells_as_arrays_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  return $self->{impl}->set_cells_as_arrays_async($mutator, $cells);
}

sub async_mutator_set_cells_serialized{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->async_mutator_set_cells_serialized($mutator, $cells, $flush);
}

sub set_cells_serialized_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  my $cells = ($request->{'cells'}) ? $request->{'cells'} : undef;
  my $flush = ($request->{'flush'}) ? $request->{'flush'} : undef;
  return $self->{impl}->set_cells_serialized_async($mutator, $cells, $flush);
}

sub async_mutator_flush{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->async_mutator_flush($mutator);
}

sub flush_mutator_async{
  my ($self, $request) = @_;

  my $mutator = ($request->{'mutator'}) ? $request->{'mutator'} : undef;
  return $self->{impl}->flush_mutator_async($mutator);
}

sub namespace_exists{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->namespace_exists($ns);
}

sub exists_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->exists_namespace($ns);
}

sub exists_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->exists_table($ns, $name);
}

sub get_table_id{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_id($ns, $table_name);
}

sub get_schema_str{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str($ns, $table_name);
}

sub get_schema_str_with_ids{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema_str_with_ids($ns, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($ns, $table_name);
}

sub get_tables{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_tables($ns);
}

sub get_listing{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  return $self->{impl}->get_listing($ns);
}

sub get_table_splits{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_table_splits($ns, $table_name);
}

sub namespace_drop{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->namespace_drop($ns, $if_exists);
}

sub drop_namespace{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_namespace($ns, $if_exists);
}

sub rename_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $new_name = ($request->{'new_name'}) ? $request->{'new_name'} : undef;
  return $self->{impl}->rename_table($ns, $name, $new_name);
}

sub drop_table{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $if_exists = ($request->{'if_exists'}) ? $request->{'if_exists'} : undef;
  return $self->{impl}->drop_table($ns, $name, $if_exists);
}

sub generate_guid{
  my ($self, $request) = @_;

  return $self->{impl}->generate_guid();
}

sub create_cell_unique{
  my ($self, $request) = @_;

  my $ns = ($request->{'ns'}) ? $request->{'ns'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->create_cell_unique($ns, $table_name, $key, $value);
}

package Hypertable::ThriftGen::ClientServiceClient;


use base qw(Hypertable::ThriftGen::ClientServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub namespace_create{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_create($ns);
  $self->recv_namespace_create();
}

sub send_namespace_create{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_create', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_create_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_create_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub create_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_create_namespace($ns);
  $self->recv_create_namespace();
}

sub send_create_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('create_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_create_table($ns, $table_name, $schema);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

    $self->send_alter_table($ns, $table_name, $schema);
  $self->recv_alter_table();
}

sub send_alter_table{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $schema = shift;

  $self->{output}->writeMessageBegin('alter_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_alter_table_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{schema} = $schema;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_alter_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_open{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_open($ns);
  return $self->recv_namespace_open();
}

sub send_namespace_open{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_open_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_open failed: unknown result";
}
sub open_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_open_namespace($ns);
  return $self->recv_open_namespace();
}

sub send_open_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('open_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_namespace failed: unknown result";
}
sub namespace_close{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_close($ns);
  $self->recv_namespace_close();
}

sub send_namespace_close{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_close_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_close_namespace($ns);
  $self->recv_close_namespace();
}

sub send_close_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('close_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_open{
  my $self = shift;
  my $queue_size = shift;

    $self->send_future_open($queue_size);
  return $self->recv_future_open();
}

sub send_future_open{
  my $self = shift;
  my $queue_size = shift;

  $self->{output}->writeMessageBegin('future_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_open_args();
  $args->{queue_size} = $queue_size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_open failed: unknown result";
}
sub open_future{
  my $self = shift;
  my $queue_size = shift;

    $self->send_open_future($queue_size);
  return $self->recv_open_future();
}

sub send_open_future{
  my $self = shift;
  my $queue_size = shift;

  $self->{output}->writeMessageBegin('open_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_future_args();
  $args->{queue_size} = $queue_size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_future failed: unknown result";
}
sub future_cancel{
  my $self = shift;
  my $ff = shift;

    $self->send_future_cancel($ff);
  $self->recv_future_cancel();
}

sub send_future_cancel{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_cancel_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_future{
  my $self = shift;
  my $ff = shift;

    $self->send_cancel_future($ff);
  $self->recv_cancel_future();
}

sub send_cancel_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('cancel_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_future_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub future_get_result{
  my $self = shift;
  my $ff = shift;

    $self->send_future_get_result($ff);
  return $self->recv_future_get_result();
}

sub send_future_get_result{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_get_result', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result failed: unknown result";
}
sub get_future_result{
  my $self = shift;
  my $ff = shift;

    $self->send_get_future_result($ff);
  return $self->recv_get_future_result();
}

sub send_get_future_result{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('get_future_result', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result failed: unknown result";
}
sub future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;

    $self->send_future_get_result_as_arrays($ff);
  return $self->recv_future_get_result_as_arrays();
}

sub send_future_get_result_as_arrays{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_get_result_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_as_arrays failed: unknown result";
}
sub get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;

    $self->send_get_future_result_as_arrays($ff);
  return $self->recv_get_future_result_as_arrays();
}

sub send_get_future_result_as_arrays{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('get_future_result_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_as_arrays failed: unknown result";
}
sub future_get_result_serialized{
  my $self = shift;
  my $ff = shift;

    $self->send_future_get_result_serialized($ff);
  return $self->recv_future_get_result_serialized();
}

sub send_future_get_result_serialized{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_get_result_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_get_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_get_result_serialized failed: unknown result";
}
sub get_future_result_serialized{
  my $self = shift;
  my $ff = shift;

    $self->send_get_future_result_serialized($ff);
  return $self->recv_get_future_result_serialized();
}

sub send_get_future_result_serialized{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('get_future_result_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_future_result_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_future_result_serialized failed: unknown result";
}
sub future_is_empty{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_empty($ff);
  return $self->recv_future_is_empty();
}

sub send_future_is_empty{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_empty', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_empty_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_empty{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_empty_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_empty failed: unknown result";
}
sub future_is_full{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_full($ff);
  return $self->recv_future_is_full();
}

sub send_future_is_full{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_full', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_full_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_full{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_full_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_full failed: unknown result";
}
sub future_is_cancelled{
  my $self = shift;
  my $ff = shift;

    $self->send_future_is_cancelled($ff);
  return $self->recv_future_is_cancelled();
}

sub send_future_is_cancelled{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_is_cancelled', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_is_cancelled_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_is_cancelled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_is_cancelled_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_is_cancelled failed: unknown result";
}
sub future_has_outstanding{
  my $self = shift;
  my $ff = shift;

    $self->send_future_has_outstanding($ff);
  return $self->recv_future_has_outstanding();
}

sub send_future_has_outstanding{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_has_outstanding', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_has_outstanding_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_has_outstanding{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_has_outstanding_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "future_has_outstanding failed: unknown result";
}
sub future_close{
  my $self = shift;
  my $ff = shift;

    $self->send_future_close($ff);
  $self->recv_future_close();
}

sub send_future_close{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('future_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_future_close_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_future_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_future_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_future{
  my $self = shift;
  my $ff = shift;

    $self->send_close_future($ff);
  $self->recv_close_future();
}

sub send_close_future{
  my $self = shift;
  my $ff = shift;

  $self->{output}->writeMessageBegin('close_future', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_future_args();
  $args->{ff} = $ff;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_future{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_future_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_scanner_open($ns, $table_name, $scan_spec);
  return $self->recv_scanner_open();
}

sub send_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('scanner_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_open failed: unknown result";
}
sub open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_open_scanner($ns, $table_name, $scan_spec);
  return $self->recv_open_scanner();
}

sub send_open_scanner{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner failed: unknown result";
}
sub async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_async_scanner_open($ns, $table_name, $future, $scan_spec);
  return $self->recv_async_scanner_open();
}

sub send_async_scanner_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('async_scanner_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_scanner_open failed: unknown result";
}
sub open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

    $self->send_open_scanner_async($ns, $table_name, $future, $scan_spec);
  return $self->recv_open_scanner_async();
}

sub send_open_scanner_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('open_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_scanner_async_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_scanner_async failed: unknown result";
}
sub scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_close($scanner);
  $self->recv_scanner_close();
}

sub send_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_close_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner($scanner);
  $self->recv_close_scanner();
}

sub send_close_scanner{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_cancel($scanner);
  $self->recv_async_scanner_cancel();
}

sub send_async_scanner_cancel{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_cancel_scanner_async($scanner);
  $self->recv_cancel_scanner_async();
}

sub send_cancel_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('cancel_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_scanner_close{
  my $self = shift;
  my $scanner = shift;

    $self->send_async_scanner_close($scanner);
  $self->recv_async_scanner_close();
}

sub send_async_scanner_close{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('async_scanner_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_scanner_close_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_scanner_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_scanner_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_scanner_async{
  my $self = shift;
  my $scanner = shift;

    $self->send_close_scanner_async($scanner);
  $self->recv_close_scanner_async();
}

sub send_close_scanner_async{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('close_scanner_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_scanner_async_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_scanner_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_scanner_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells($scanner);
  return $self->recv_scanner_get_cells();
}

sub send_scanner_get_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells failed: unknown result";
}
sub next_cells{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells($scanner);
  return $self->recv_next_cells();
}

sub send_next_cells{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells failed: unknown result";
}
sub scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_as_arrays($scanner);
  return $self->recv_scanner_get_cells_as_arrays();
}

sub send_scanner_get_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_cells_as_arrays failed: unknown result";
}
sub next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_as_arrays($scanner);
  return $self->recv_next_cells_as_arrays();
}

sub send_next_cells_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_cells_as_arrays failed: unknown result";
}
sub scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_cells_serialized($scanner);
  return $self->recv_scanner_get_cells_serialized();
}

sub send_scanner_get_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "scanner_get_cells_serialized failed: unknown result";
}
sub next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_cells_serialized($scanner);
  return $self->recv_next_cells_serialized();
}

sub send_next_cells_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_cells_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "next_cells_serialized failed: unknown result";
}
sub scanner_get_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row($scanner);
  return $self->recv_scanner_get_row();
}

sub send_scanner_get_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row failed: unknown result";
}
sub next_row{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row($scanner);
  return $self->recv_next_row();
}

sub send_next_row{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row failed: unknown result";
}
sub scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_as_arrays($scanner);
  return $self->recv_scanner_get_row_as_arrays();
}

sub send_scanner_get_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_as_arrays failed: unknown result";
}
sub next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_as_arrays($scanner);
  return $self->recv_next_row_as_arrays();
}

sub send_next_row_as_arrays{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_as_arrays failed: unknown result";
}
sub scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_scanner_get_row_serialized($scanner);
  return $self->recv_scanner_get_row_serialized();
}

sub send_scanner_get_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('scanner_get_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scanner_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "scanner_get_row_serialized failed: unknown result";
}
sub next_row_serialized{
  my $self = shift;
  my $scanner = shift;

    $self->send_next_row_serialized($scanner);
  return $self->recv_next_row_serialized();
}

sub send_next_row_serialized{
  my $self = shift;
  my $scanner = shift;

  $self->{output}->writeMessageBegin('next_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_next_row_serialized_args();
  $args->{scanner} = $scanner;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_next_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_next_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "next_row_serialized failed: unknown result";
}
sub get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row($ns, $table_name, $row);
  return $self->recv_get_row();
}

sub send_get_row{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row failed: unknown result";
}
sub get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

    $self->send_get_row_as_arrays($ns, $name, $row);
  return $self->recv_get_row_as_arrays();
}

sub send_get_row_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_as_arrays failed: unknown result";
}
sub get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

    $self->send_get_row_serialized($ns, $table_name, $row);
  return $self->recv_get_row_serialized();
}

sub send_get_row_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('get_row_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_row_serialized_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_row_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_row_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_row_serialized failed: unknown result";
}
sub get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

    $self->send_get_cell($ns, $table_name, $row, $column);
  return $self->recv_get_cell();
}

sub send_get_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $row = shift;
  my $column = shift;

  $self->{output}->writeMessageBegin('get_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cell failed: unknown result";
}
sub get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

    $self->send_get_cells($ns, $table_name, $scan_spec);
  return $self->recv_get_cells();
}

sub send_get_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells failed: unknown result";
}
sub get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_as_arrays($ns, $name, $scan_spec);
  return $self->recv_get_cells_as_arrays();
}

sub send_get_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_as_arrays failed: unknown result";
}
sub get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

    $self->send_get_cells_serialized($ns, $name, $scan_spec);
  return $self->recv_get_cells_serialized();
}

sub send_get_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $scan_spec = shift;

  $self->{output}->writeMessageBegin('get_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_cells_serialized_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{scan_spec} = $scan_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_cells_serialized failed: unknown result";
}
sub refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

    $self->send_refresh_shared_mutator($ns, $table_name, $mutate_spec);
  $self->recv_refresh_shared_mutator();
}

sub send_refresh_shared_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;

  $self->{output}->writeMessageBegin('refresh_shared_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_refresh_shared_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells();
}

sub send_offer_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

    $self->send_offer_cells_as_arrays($ns, $table_name, $mutate_spec, $cells);
  $self->recv_offer_cells_as_arrays();
}

sub send_offer_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('offer_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell();
}

sub send_offer_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

    $self->send_offer_cell_as_array($ns, $table_name, $mutate_spec, $cell);
  $self->recv_offer_cell_as_array();
}

sub send_offer_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $mutate_spec = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('offer_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{mutate_spec} = $mutate_spec;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_offer_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_mutator_open($ns, $table_name, $flags, $flush_interval);
  return $self->recv_mutator_open();
}

sub send_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('mutator_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "mutator_open failed: unknown result";
}
sub open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

    $self->send_open_mutator($ns, $table_name, $flags, $flush_interval);
  return $self->recv_open_mutator();
}

sub send_open_mutator{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $flags = shift;
  my $flush_interval = shift;

  $self->{output}->writeMessageBegin('open_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{flags} = $flags;
  $args->{flush_interval} = $flush_interval;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator failed: unknown result";
}
sub async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_async_mutator_open($ns, $table_name, $future, $flags);
  return $self->recv_async_mutator_open();
}

sub send_async_mutator_open{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('async_mutator_open', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_open_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "async_mutator_open failed: unknown result";
}
sub open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

    $self->send_open_mutator_async($ns, $table_name, $future, $flags);
  return $self->recv_open_mutator_async();
}

sub send_open_mutator_async{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $future = shift;
  my $flags = shift;

  $self->{output}->writeMessageBegin('open_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_open_mutator_async_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{future} = $future;
  $args->{flags} = $flags;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_open_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "open_mutator_async failed: unknown result";
}
sub mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_close($mutator);
  $self->recv_mutator_close();
}

sub send_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_close_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator($mutator);
  $self->recv_close_mutator();
}

sub send_close_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_cancel($mutator);
  $self->recv_async_mutator_cancel();
}

sub send_async_mutator_cancel{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_cancel', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_cancel{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_cancel_mutator_async($mutator);
  $self->recv_cancel_mutator_async();
}

sub send_cancel_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('cancel_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_close{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_close($mutator);
  $self->recv_async_mutator_close();
}

sub send_async_mutator_close{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_close', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_close_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub close_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_close_mutator_async($mutator);
  $self->recv_close_mutator_async();
}

sub send_close_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('close_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_close_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_close_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell($mutator, $cell);
  $self->recv_mutator_set_cell();
}

sub send_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell($ns, $table_name, $cell);
  $self->recv_set_cell();
}

sub send_set_cell{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_mutator_set_cell_as_array();
}

sub send_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('mutator_set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

    $self->send_set_cell_as_array($ns, $table_name, $cell);
  $self->recv_set_cell_as_array();
}

sub send_set_cell_as_array{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells($mutator, $cells);
  $self->recv_mutator_set_cells();
}

sub send_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells($ns, $table_name, $cells);
  $self->recv_set_cells();
}

sub send_set_cells{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_mutator_set_cells_as_arrays();
}

sub send_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays($ns, $table_name, $cells);
  $self->recv_set_cells_as_arrays();
}

sub send_set_cells_as_arrays{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_mutator_set_cells_serialized();
}

sub send_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('mutator_set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_set_cells_serialized($ns, $table_name, $cells, $flush);
  $self->recv_set_cells_serialized();
}

sub send_set_cells_serialized{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_mutator_flush($mutator);
  $self->recv_mutator_flush();
}

sub send_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('mutator_flush', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_mutator_flush_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_mutator_flush_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator($mutator);
  $self->recv_flush_mutator();
}

sub send_flush_mutator{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell($mutator, $cell);
  $self->recv_async_mutator_set_cell();
}

sub send_async_mutator_set_cell{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_async($mutator, $cell);
  $self->recv_set_cell_async();
}

sub send_set_cell_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_async_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_async_mutator_set_cell_as_array($mutator, $cell);
  $self->recv_async_mutator_set_cell_as_array();
}

sub send_async_mutator_set_cell_as_array{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cell_as_array', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cell_as_array{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

    $self->send_set_cell_as_array_async($mutator, $cell);
  $self->recv_set_cell_as_array_async();
}

sub send_set_cell_as_array_async{
  my $self = shift;
  my $mutator = shift;
  my $cell = shift;

  $self->{output}->writeMessageBegin('set_cell_as_array_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args();
  $args->{mutator} = $mutator;
  $args->{cell} = $cell;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cell_as_array_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells($mutator, $cells);
  $self->recv_async_mutator_set_cells();
}

sub send_async_mutator_set_cells{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_async($mutator, $cells);
  $self->recv_set_cells_async();
}

sub send_set_cells_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_async_mutator_set_cells_as_arrays($mutator, $cells);
  $self->recv_async_mutator_set_cells_as_arrays();
}

sub send_async_mutator_set_cells_as_arrays{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_as_arrays', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_as_arrays{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

    $self->send_set_cells_as_arrays_async($mutator, $cells);
  $self->recv_set_cells_as_arrays_async();
}

sub send_set_cells_as_arrays_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;

  $self->{output}->writeMessageBegin('set_cells_as_arrays_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_as_arrays_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_async_mutator_set_cells_serialized($mutator, $cells, $flush);
  $self->recv_async_mutator_set_cells_serialized();
}

sub send_async_mutator_set_cells_serialized{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('async_mutator_set_cells_serialized', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_set_cells_serialized{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

    $self->send_set_cells_serialized_async($mutator, $cells, $flush);
  $self->recv_set_cells_serialized_async();
}

sub send_set_cells_serialized_async{
  my $self = shift;
  my $mutator = shift;
  my $cells = shift;
  my $flush = shift;

  $self->{output}->writeMessageBegin('set_cells_serialized_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args();
  $args->{mutator} = $mutator;
  $args->{cells} = $cells;
  $args->{flush} = $flush;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cells_serialized_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

    $self->send_async_mutator_flush($mutator);
  $self->recv_async_mutator_flush();
}

sub send_async_mutator_flush{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('async_mutator_flush', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_async_mutator_flush_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_async_mutator_flush{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_async_mutator_flush_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

    $self->send_flush_mutator_async($mutator);
  $self->recv_flush_mutator_async();
}

sub send_flush_mutator_async{
  my $self = shift;
  my $mutator = shift;

  $self->{output}->writeMessageBegin('flush_mutator_async', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_async_args();
  $args->{mutator} = $mutator;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_flush_mutator_async{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_async_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub namespace_exists{
  my $self = shift;
  my $ns = shift;

    $self->send_namespace_exists($ns);
  return $self->recv_namespace_exists();
}

sub send_namespace_exists{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('namespace_exists', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_exists_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_exists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "namespace_exists failed: unknown result";
}
sub exists_namespace{
  my $self = shift;
  my $ns = shift;

    $self->send_exists_namespace($ns);
  return $self->recv_exists_namespace();
}

sub send_exists_namespace{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('exists_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_exists_namespace_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_exists_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_namespace failed: unknown result";
}
sub exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

    $self->send_exists_table($ns, $name);
  return $self->recv_exists_table();
}

sub send_exists_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('exists_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_exists_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_exists_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "exists_table failed: unknown result";
}
sub get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_id($ns, $table_name);
  return $self->recv_get_table_id();
}

sub send_get_table_id{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_id', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_id{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_id failed: unknown result";
}
sub get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str($ns, $table_name);
  return $self->recv_get_schema_str();
}

sub send_get_schema_str{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str failed: unknown result";
}
sub get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema_str_with_ids($ns, $table_name);
  return $self->recv_get_schema_str_with_ids();
}

sub send_get_schema_str_with_ids{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema_str_with_ids', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema_str_with_ids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema_str_with_ids failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_schema($ns, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_schema failed: unknown result";
}
sub get_tables{
  my $self = shift;
  my $ns = shift;

    $self->send_get_tables($ns);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_tables failed: unknown result";
}
sub get_listing{
  my $self = shift;
  my $ns = shift;

    $self->send_get_listing($ns);
  return $self->recv_get_listing();
}

sub send_get_listing{
  my $self = shift;
  my $ns = shift;

  $self->{output}->writeMessageBegin('get_listing', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_listing_args();
  $args->{ns} = $ns;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_listing{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_listing_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_listing failed: unknown result";
}
sub get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

    $self->send_get_table_splits($ns, $table_name);
  return $self->recv_get_table_splits();
}

sub send_get_table_splits{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_table_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_get_table_splits_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_get_table_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "get_table_splits failed: unknown result";
}
sub namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_namespace_drop($ns, $if_exists);
  $self->recv_namespace_drop();
}

sub send_namespace_drop{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('namespace_drop', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_namespace_drop_args();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_namespace_drop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_namespace_drop_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

    $self->send_drop_namespace($ns, $if_exists);
  $self->recv_drop_namespace();
}

sub send_drop_namespace{
  my $self = shift;
  my $ns = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_namespace', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_namespace_args();
  $args->{ns} = $ns;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_namespace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_namespace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

    $self->send_rename_table($ns, $name, $new_name);
  $self->recv_rename_table();
}

sub send_rename_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $new_name = shift;

  $self->{output}->writeMessageBegin('rename_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_rename_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{new_name} = $new_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rename_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_rename_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

    $self->send_drop_table($ns, $name, $if_exists);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $ns = shift;
  my $name = shift;
  my $if_exists = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
  $args->{ns} = $ns;
  $args->{name} = $name;
  $args->{if_exists} = $if_exists;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{e}) {
    die $result->{e};
  }
  return;
}
sub generate_guid{
  my $self = shift;

    $self->send_generate_guid();
  return $self->recv_generate_guid();
}

sub send_generate_guid{
  my $self = shift;

  $self->{output}->writeMessageBegin('generate_guid', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_generate_guid_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_generate_guid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_generate_guid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "generate_guid failed: unknown result";
}
sub create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

    $self->send_create_cell_unique($ns, $table_name, $key, $value);
  return $self->recv_create_cell_unique();
}

sub send_create_cell_unique{
  my $self = shift;
  my $ns = shift;
  my $table_name = shift;
  my $key = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('create_cell_unique', TMessageType::CALL, $self->{seqid});
  my $args = new Hypertable::ThriftGen::ClientService_create_cell_unique_args();
  $args->{ns} = $ns;
  $args->{table_name} = $table_name;
  $args->{key} = $key;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_cell_unique{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hypertable::ThriftGen::ClientService_create_cell_unique_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{e}) {
    die $result->{e};
  }
  die "create_cell_unique failed: unknown result";
}
package Hypertable::ThriftGen::ClientServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_namespace_create {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_create_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_create_result();
    eval {
      $self->{handler}->namespace_create($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_create', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_namespace_result();
    eval {
      $self->{handler}->create_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_table_result();
    eval {
      $self->{handler}->create_table($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_alter_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_alter_table_result();
    eval {
      $self->{handler}->alter_table($args->ns, $args->table_name, $args->schema);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('alter_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_open_result();
    eval {
      $result->{success} = $self->{handler}->namespace_open($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_namespace_result();
    eval {
      $result->{success} = $self->{handler}->open_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_close_result();
    eval {
      $self->{handler}->namespace_close($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_namespace_result();
    eval {
      $self->{handler}->close_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_open_result();
    eval {
      $result->{success} = $self->{handler}->future_open($args->queue_size);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_future_result();
    eval {
      $result->{success} = $self->{handler}->open_future($args->queue_size);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_cancel_result();
    eval {
      $self->{handler}->future_cancel($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_future_result();
    eval {
      $self->{handler}->cancel_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result_as_arrays($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result_as_arrays($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_get_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_get_result_serialized_result();
    eval {
      $result->{success} = $self->{handler}->future_get_result_serialized($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_get_result_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_future_result_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_future_result_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_future_result_serialized($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_future_result_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_empty {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_empty_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_empty_result();
    eval {
      $result->{success} = $self->{handler}->future_is_empty($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_empty', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_full {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_full_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_full_result();
    eval {
      $result->{success} = $self->{handler}->future_is_full($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_full', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_is_cancelled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_is_cancelled_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_is_cancelled_result();
    eval {
      $result->{success} = $self->{handler}->future_is_cancelled($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_is_cancelled', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_has_outstanding {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_has_outstanding_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_has_outstanding_result();
    eval {
      $result->{success} = $self->{handler}->future_has_outstanding($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_has_outstanding', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_future_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_future_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_future_close_result();
    eval {
      $self->{handler}->future_close($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('future_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_future {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_future_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_future_result();
    eval {
      $self->{handler}->close_future($args->ff);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_future', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_open_result();
    eval {
      $result->{success} = $self->{handler}->scanner_open($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_scanner_result();
    eval {
      $result->{success} = $self->{handler}->open_scanner($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_open_result();
    eval {
      $result->{success} = $self->{handler}->async_scanner_open($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_scanner_async_result();
    eval {
      $result->{success} = $self->{handler}->open_scanner_async($args->ns, $args->table_name, $args->future, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_close_result();
    eval {
      $self->{handler}->scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_scanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_scanner_result();
    eval {
      $self->{handler}->close_scanner($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_scanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_cancel_result();
    eval {
      $self->{handler}->async_scanner_cancel($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_scanner_async_result();
    eval {
      $self->{handler}->cancel_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_scanner_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_scanner_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_scanner_close_result();
    eval {
      $self->{handler}->async_scanner_close($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_scanner_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_scanner_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_scanner_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_scanner_async_result();
    eval {
      $self->{handler}->close_scanner_async($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_scanner_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_result();
    eval {
      $result->{success} = $self->{handler}->next_cells($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_cells_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_cells_serialized_result();
    $result->{success} = $self->{handler}->scanner_get_cells_serialized($args->scanner);
    $output->writeMessageBegin('scanner_get_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_cells_serialized_result();
    $result->{success} = $self->{handler}->next_cells_serialized($args->scanner);
    $output->writeMessageBegin('next_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_result();
    eval {
      $result->{success} = $self->{handler}->next_row($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->next_row_as_arrays($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scanner_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_scanner_get_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->scanner_get_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('scanner_get_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_next_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_next_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_next_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->next_row_serialized($args->scanner);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('next_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_result();
    eval {
      $result->{success} = $self->{handler}->get_row($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_row_as_arrays($args->ns, $args->name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_row_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_row_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_row_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_row_serialized($args->ns, $args->table_name, $args->row);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_row_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cell_result();
    eval {
      $result->{success} = $self->{handler}->get_cell($args->ns, $args->table_name, $args->row, $args->column);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_result();
    eval {
      $result->{success} = $self->{handler}->get_cells($args->ns, $args->table_name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_as_arrays_result();
    eval {
      $result->{success} = $self->{handler}->get_cells_as_arrays($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_cells_serialized_result();
    eval {
      $result->{success} = $self->{handler}->get_cells_serialized($args->ns, $args->name, $args->scan_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_refresh_shared_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_refresh_shared_mutator_result();
    eval {
      $self->{handler}->refresh_shared_mutator($args->ns, $args->table_name, $args->mutate_spec);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('refresh_shared_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cells_result();
    eval {
      $self->{handler}->offer_cells($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cells_as_arrays_result();
    eval {
      $self->{handler}->offer_cells_as_arrays($args->ns, $args->table_name, $args->mutate_spec, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cell_result();
    eval {
      $self->{handler}->offer_cell($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_offer_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_offer_cell_as_array_result();
    eval {
      $self->{handler}->offer_cell_as_array($args->ns, $args->table_name, $args->mutate_spec, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('offer_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_open_result();
    eval {
      $result->{success} = $self->{handler}->mutator_open($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_mutator_result();
    eval {
      $result->{success} = $self->{handler}->open_mutator($args->ns, $args->table_name, $args->flags, $args->flush_interval);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_open {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_open_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_open_result();
    eval {
      $result->{success} = $self->{handler}->async_mutator_open($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_open', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_open_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_open_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_open_mutator_async_result();
    eval {
      $result->{success} = $self->{handler}->open_mutator_async($args->ns, $args->table_name, $args->future, $args->flags);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('open_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_close_result();
    eval {
      $self->{handler}->mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_mutator_result();
    eval {
      $self->{handler}->close_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_cancel {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_cancel_result();
    eval {
      $self->{handler}->async_mutator_cancel($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_cancel', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_cancel_mutator_async_result();
    eval {
      $self->{handler}->cancel_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('cancel_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_close {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_close_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_close_result();
    eval {
      $self->{handler}->async_mutator_close($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_close', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_close_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_close_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_close_mutator_async_result();
    eval {
      $self->{handler}->close_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('close_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_result();
    eval {
      $self->{handler}->mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_result();
    eval {
      $self->{handler}->set_cell($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cell_as_array_result();
    eval {
      $self->{handler}->mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_result();
    eval {
      $self->{handler}->set_cell_as_array($args->ns, $args->table_name, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_result();
    eval {
      $self->{handler}->mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_result();
    eval {
      $self->{handler}->set_cells($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_as_arrays_result();
    eval {
      $self->{handler}->mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_result();
    eval {
      $self->{handler}->set_cells_as_arrays($args->ns, $args->table_name, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_set_cells_serialized_result();
    eval {
      $self->{handler}->mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_result();
    eval {
      $self->{handler}->set_cells_serialized($args->ns, $args->table_name, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_mutator_flush_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_mutator_flush_result();
    eval {
      $self->{handler}->mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('mutator_flush', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_result();
    eval {
      $self->{handler}->flush_mutator($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('flush_mutator', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_result();
    eval {
      $self->{handler}->async_mutator_set_cell($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cell', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_async_result();
    eval {
      $self->{handler}->set_cell_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cell_as_array {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cell_as_array_result();
    eval {
      $self->{handler}->async_mutator_set_cell_as_array($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cell_as_array', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cell_as_array_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cell_as_array_async_result();
    eval {
      $self->{handler}->set_cell_as_array_async($args->mutator, $args->cell);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cell_as_array_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_result();
    eval {
      $self->{handler}->async_mutator_set_cells($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_async_result();
    eval {
      $self->{handler}->set_cells_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_as_arrays {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_as_arrays_result();
    eval {
      $self->{handler}->async_mutator_set_cells_as_arrays($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells_as_arrays', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_as_arrays_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_as_arrays_async_result();
    eval {
      $self->{handler}->set_cells_as_arrays_async($args->mutator, $args->cells);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_as_arrays_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_set_cells_serialized {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_set_cells_serialized_result();
    eval {
      $self->{handler}->async_mutator_set_cells_serialized($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_set_cells_serialized', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cells_serialized_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_set_cells_serialized_async_result();
    eval {
      $self->{handler}->set_cells_serialized_async($args->mutator, $args->cells, $args->flush);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('set_cells_serialized_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_async_mutator_flush {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_async_mutator_flush_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_async_mutator_flush_result();
    eval {
      $self->{handler}->async_mutator_flush($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('async_mutator_flush', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_flush_mutator_async {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_flush_mutator_async_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_flush_mutator_async_result();
    eval {
      $self->{handler}->flush_mutator_async($args->mutator);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('flush_mutator_async', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_exists_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_exists_result();
    eval {
      $result->{success} = $self->{handler}->namespace_exists($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_exists', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_exists_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_exists_namespace_result();
    eval {
      $result->{success} = $self->{handler}->exists_namespace($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('exists_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_exists_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_exists_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_exists_table_result();
    eval {
      $result->{success} = $self->{handler}->exists_table($args->ns, $args->name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('exists_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_id {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_table_id_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_table_id_result();
    eval {
      $result->{success} = $self->{handler}->get_table_id($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_table_id', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_result();
    eval {
      $result->{success} = $self->{handler}->get_schema_str($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema_str', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema_str_with_ids {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_str_with_ids_result();
    eval {
      $result->{success} = $self->{handler}->get_schema_str_with_ids($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema_str_with_ids', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_listing {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_listing_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_listing_result();
    eval {
      $result->{success} = $self->{handler}->get_listing($args->ns);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_listing', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_get_table_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_get_table_splits_result();
    eval {
      $result->{success} = $self->{handler}->get_table_splits($args->ns, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('get_table_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_namespace_drop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_namespace_drop_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_namespace_drop_result();
    eval {
      $self->{handler}->namespace_drop($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('namespace_drop', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_namespace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_drop_namespace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_drop_namespace_result();
    eval {
      $self->{handler}->drop_namespace($args->ns, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('drop_namespace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_rename_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_rename_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_rename_table_result();
    eval {
      $self->{handler}->rename_table($args->ns, $args->name, $args->new_name);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('rename_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->ns, $args->name, $args->if_exists);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_generate_guid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_generate_guid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_generate_guid_result();
    $result->{success} = $self->{handler}->generate_guid();
    $output->writeMessageBegin('generate_guid', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_cell_unique {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hypertable::ThriftGen::ClientService_create_cell_unique_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hypertable::ThriftGen::ClientService_create_cell_unique_result();
    eval {
      $result->{success} = $self->{handler}->create_cell_unique($args->ns, $args->table_name, $args->key, $args->value);
    }; if( UNIVERSAL::isa($@,'Hypertable::ThriftGen::ClientException') ){ 
      $result->{e} = $@;
    }
    $output->writeMessageBegin('create_cell_unique', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
